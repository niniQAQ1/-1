第一题
factor = int(input("Enter a factor: "))
maxi = int(input("Enter a maximum: "))
total = 0 #设置一个空篮子，等着装东西
#while循环里，必须手动设置计数器，比如i = 0 之类，但在for循环里不需要这样做，for后面相当于i的设置
for i in range(1, maxium + 1):#因为range（a，b）生成的是从a到b-1，如果写range（1， maximum）就会少算maximum本身，所以要这样才能包含最大值
    if i % factor == 0:
        total += i
print（

第二题
data = [0, -2, 15, 0, 0, -1, 1, -26] #写一个里面有数字的列表
clean_data = []#设一个空列表篮子
count = 0 #设一个叫count的篮子
while count < len(data): #规定条件，当count的次数少于列表的长度（这个后面的加一没加到7时，加八次，从0到7）时
    number = data[count] #取出列表里的count的那个元素，注意是个，取出来放到number篮子里
    if number != 0: #看看这个number等不等于0，如果不等于
        clean_data += [number] #就把这个数加到（拼接到） clean——data列表里
    count += 1 #count每次循环 + 1
print(f"Non zero data: {clean_data}")

第三题
data = [] #设置一个名为data的空列表
new_data = input("Add a word (blank to exit): ") #给用户输入的信息放到new——data这个篮子里
while new_data != "": #当用户输入的信息不是空的时，就继续循环
    if new_data not in data: #如果new——data不是在data列表中的
        data += [new_data] #data要加上 new——data里的，就是吧用户输入的信息一个个放到原本是空的data列表里（append）
    new_data = input("Add a word (blank to exit): ")#然后在问用户要新的输入，一直循环
print(f"Words: {data}") #然后格式化输出data列表

第四题
data = [5, -2, 10, 0, -2, 4, 10, 6] #先打一个data列表上去
smallest = 0 #设个smallest空篮子，在这里是假设最小值在index0的位置
count = 0 #设个count空篮子，在这里是让count从0开始，表示正在看的第0个元素
while count < len(data): #当count篮子里的数小于data列表长度的数（0-7，所以是8）时，就是当count小于8时就继续循环，这样count会依次取列表里的0:7
    if data[count] < data[smallest]: #如果当前检查的元素（data列表里的count位）比data列表里的smallest位更小（根据后面代码的意思是保存的最小值）
        smallest = count #就把smallest重定义成count，就是更新smallest
    count += 1#count每次循环都+1直到触及到7 #因为count += 1这行的缩进是4不是8，所以不受上面if条件的影响
#就是第一从循环时是if data【0】小于 data【0】，这不成立，所以跑到下面的count += 1，真正的循环是在第二次才开始的，这是是 if data[1] < data[0],就是比较5 和 -2的大小，因为5比-2大
所以条件达成，重新定义smallest，又是count += 1，因为-2比5小，所以现在暂时锁定这个smallest的条件，现在是if data【2】小于 data【1】，就是对比10和-2的大小，不成立，然后往后对比，
都不成立，知道 count += 1触碰到while那行设定的条件

biggest = len(data) - 1 #设定biggest的index为data列表的长度-1，就是7
count = biggest #把count的数重定义为biggest的数，就是7
while count >= 0:#当count大于等于0时
    if data[count] > data[biggest]#如果data c index的元素大于data b index的元素，这里第一次循环不成立，因为是一样的，所以转到count -= 1，用第5的去对比第6位的，条件不达成，count变4 biggest不变
然后循环对比直到 count -= 1的循环被打破（减到0了）
        biggest = count #把biggest的数换成count的数
    count -= 1 #count每次循环都-1直到触及0
subsequence = data[smallest:biggest+1] #data[1:6+1]#这一行用到了slice（切片）就是取出列表里1到7的元素，就是第二位到最后一位，如果是【a，b】就是取到b之前到那个元素，不包含b本身
print(subsequence)#然后打印这个列表
